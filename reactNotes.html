<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600&display=swap"
        rel="stylesheet" />

    <style>
        /* Reset & Global */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            line-height: 1.8;
            display: block;
            /* Changed from flex to block to avoid horizontal stacking */
            min-height: 100vh;
        }

        /* Sidebar */
        nav.sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: linear-gradient(180deg, #161b22, #30363d);
            color: #c9d1d9;
            padding: 25px 18px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        nav.sidebar ul {
            list-style: none !important;
            /* Remove all list styles */
            list-style-type: none !important;
            /* Explicitly remove bullet points */
            margin: 0;
            padding: 0;
        }

        nav.sidebar ul li {
            margin: 18px 0;
            list-style: none !important;
        }

        nav.sidebar ul li a {
            color: #c9d1d9;
            text-decoration: none;
            font-size: 1.15rem;
            display: block;
            padding: 10px 18px;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        nav.sidebar ul li a:hover {
            background-color: rgb(87, 187, 224);
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
            color: #d1e7dd;
        }


        /* nav */
        .navbar{
            position: fixed;
            display: flex;
            justify-content: space-around;
            width: calc(100vw - 260px);
            margin-left: 250px;
            height: 50px;
            background-color: rgb(23, 28, 35);
        }

        .navelement{
            border-left: 2px solid gray;
            width: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
        }


        /* Main Content */
        main {
            margin-left: 260px;
            padding: 70px 40px;
            width: calc(100% - 260px);
            background-color: #0d1117;
        }

        /* Note Section Container */
        .note-section {
            background-color: #161b22;
            padding: 30px 25px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* Level 1 Notes */
        .note-l1 {
            margin-bottom: 30px;
            width: 100%;
        }

        .note-l1 h2 {
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            color: rgb(85, 131, 236);
            background-color: #21262d;
            padding: 5px 18px;
            border-radius: 5px;
        }

        .note-l1>p {
            font-size: 1.3rem;
            color: #adbac7;
            margin-top: 15px;
            margin-bottom: 20px;
        }

        /* Level 2 Notes */
        .note-l2 {
            background-color: #1f2a38;
            padding: 22px 20px;
            margin-top: 15px;
            margin-bottom: 30px;
            border-radius: 10px;
            width: 100%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.3s ease, transform 0.3s ease;
        }

        .note-l2 h3 {
            font-size: 1.6rem;
            font-weight: 600;
            color: rgb(84, 184, 207);
            margin-bottom: 8px;
        }

        .note-l2 p {
            font-size: 1.15rem;
            color: #8b949e;
            margin-bottom: 18px;
            margin-top: 20px;
        }

        /* Level 3 Notes */
        .note-l3 {
            background-color: #2a3442;
            padding: 16px 14px;
            margin-top: 20px;
            border-radius: 7px;
            width: 100%;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
        }

        .note-l3 h4 {
            font-size: 1.3rem;
            font-weight: 500;
            color: rgb(154, 113, 231);
            margin-bottom: 10px;
        }

        .note-l3 p {
            font-size: 1.15rem;
            margin-bottom: 10px;
            color: #b1bac4;
        }

        /* Code Section Style */
        .code-container {
            background-color: #0d1117;
            padding: 15px 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-top: 20px;
            width: 100%;
            display: inline-block;
            text-align: left;
        }

        .code-container code {
            color: #c9d1d9;
            font-size: 16px;
            font-family: monospace;
            white-space: pre-line;
            display: block;
            line-height: 2rem;
            margin: 0;
            padding: 0;
        }

        .code-container code::first-line {
            line-height: 0;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 1rem;
            color: #c9d1d9;
        }

        table,
        th,
        td {
            border: 3px solid #373e47;
            padding: 14px 16px;
        }

        th {
            background-color: #21262d;
            font-weight: 700;
            color: #58a6ff;
        }

        caption {
            font-size: 1.25rem;
            margin-bottom: 12px;
            font-weight: 600;
            color: #58a6ff;
        }

        .bolder {
            font-weight: 900;
            font-size: 1.1em;
            filter: brightness(1.2);
        }

        /* lists ul, ol */
        ul:not(.sidebar ul),
        ol:not(.sidebar ol) {
            padding-left: 25px;
            margin-bottom: 20px;
            color: #adbac7;
            font-size: 1.2rem;
        }

        ul:not(.sidebar) li {
            list-style-type: disc;
            margin-bottom: 10px;
        }

        ol:not(.sidebar) li {
            list-style-type: decimal;
            margin-bottom: 10px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-260px);
                width: 220px;
                transition: transform 0.3s ease;
            }

            .sidebar.active {
                transform: translateX(0);
            }

            main {
                margin-left: 0;
                width: 100%;
                padding: 25px 20px;
            }

            .note-l1 h2 {
                position: static;
                border-radius: 5px;
            }
        }

        /* Mobile Menu Toggle Button */
        .menu-toggle {
            display: none;
            position: fixed;
            top: 18px;
            left: 18px;
            background-color: #238636;
            color: #d1e7dd;
            border: none;
            padding: 11px 16px;
            border-radius: 6px;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.1rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            user-select: none;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }
        }
    </style>
</head>

<body>
    <!-- Sidebar & Menu Toggle -->
    <button class="menu-toggle" aria-label="Toggle menu">☰ Menu</button>
    <nav class="sidebar" aria-label="Sidebar Navigation">
        <ul>
            <li><a href="#section1">React</a></li>
            <li><a href="#section2">Setup and Project Structure</a></li>
            <li><a href="#section3">React Components</a></li>
            <li><a href="#section4">Import, Export</a></li>
            <li><a href="#section5">Writing Markup with JSX</a></li>
            <li><a href="#section6">JavaScript in JSX with Curly Braces</a></li>
            <li><a href="#section7">React Fragments</a></li>
            <li><a href="#section8">React Props</a></li>
            <li><a href="#section9">Conditional Rendering</a></li>
            <li><a href="#section10">Events</a></li>
            <li><a href="#section11">State</a></li>
            <li><a href="#section12">Forms in React</a></li>
            <li><a href="#section13">useEffect</a></li>
            <li><a href="#section14">Material UI</a></li>
        </ul>
    </nav>


    <div class="navbar">
        <a href="https://indersauwalia.github.io/web-dev-notes/javascript.html" class="navelement js"
            style="color: #f7df1e;">
            Javascript <i class="fa-brands fa-js"></i>
        </a>
        <a href="https://indersauwalia.github.io/web-dev-notes/node-express.html" class="navelement nodex"
            style="color: #339933;">
            Node.js, Express.js <i class="fa-brands fa-node-js"></i>
        </a>
        <a href="https://indersauwalia.github.io/web-dev-notes/mongodb.html" class="navelement mongo"
            style="color: #47a248;">
            MongoDB <i class="fa-brands fa-envira"></i>
        </a>
        <a href="https://indersauwalia.github.io/web-dev-notes/reactNotes.html" class="navelement react"
            style="color: #61dafb;">
            React <i class="fa-brands fa-react"></i>
        </a>
        <a href="https://indersauwalia.github.io/web-dev-notes/cssnotes.html" class="navelement css" style="color: #264de4;">
            CSS <i class="fa-brands fa-css3-alt"></i>
        </a>
    </div>


    <main>
        <!-- React -->
        <section id="section1" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>React</h2>
                <p>
                    React.js is an open-source JavaScript library used for building user interfaces (UIs), especially single-page applications (SPAs) where you need a fast, interactive, and dynamic user experience.
                </p>
                <div class="note-l2">
                    <h3>Key features of React include:</h3>
                    <p>
                        <ul>
                            <li><span class="bolder">Component-Based Architecture:</span> Build encapsulated components that manage their own state and can be composed to create complex UIs.</li>
                            <li><span class="bolder">Virtual DOM:</span> React keeps a lightweight representation of the DOM in memory, comparing it with the actual DOM to apply only necessary updates, enhancing performance.</li>
                            <li><span class="bolder">JSX:</span> A syntax extension that allows you to write HTML-like code within JavaScript, making the code more readable and expressive.</li>
                            <li><span class="bolder">Unidirectional Data Flow:</span> Data flows in one direction, making it easier to understand and predict how changes affect the application.</li>
                            <li><span class="bolder">Ecosystem and Tools:</span> React has a rich ecosystem with tools like React Router for routing, Redux for state management, and Next.js for server-side rendering.</li>
                        </ul>
                    </p>
                </div>
                <div class="code-container">
                    <code>
                        //Example:
                        function Greeting(props) {
                            &nbsp;&nbsp;return &lt;h1&gt; Hello, {props.name}! &lt;/h1&gt;;
                        }

                        //This is a React component that displays a personalized greeting.
                    </code>
                </div>
            </div>
        </section>


        <!-- Setup And Project Structure -->
        <section id="section2" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Setup And Project Structure</h2>
                <div class="note-l2">
                    <h3>Vite</h3>
                    <p>
                        Setting up React with Vite is one of the fastest and easiest ways to start a modern React project. Vite is a modern build tool that's faster and more optimized than Create React App (CRA). Here's a step-by-step guide to setting up React with Vite:
                    </p>
                    <div class="code-container">
                        <code>
                            //Steps:
                            //1.Create a New React Project:
                            npm create vite@latest

                            //2.Enter project details e.g:
                            Project name: my-react-app
                            Framework: React
                            Variant: JavaScript or TypeScript e.t.c

                            //3. Move into project folder:
                            cd my-react-app

                            //4.Install dependencies:
                            npm install

                            <hr>
                            //To start a react server:
                            npm run dev
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Project Structure</h3>
                    <div class="code-container">
                        <code>
                            //Vite creates a simple structure:
                            my-react-app/
                            ├── node_modules/ → Installed packages (auto-generated)
                            ├── public/ → Public static files
                            │ └── vite.svg → Default Vite logo (can be used in app)
                            ├── src/ → All your React code lives here
                            │ ├── assets/ → Place images, SVGs, or static assets
                            │ ├── App.jsx → Main component (root UI)
                            │ ├── main.jsx → App entry point (renders &lt;App /&gt;)
                            │ └── index.css → Global styles
                            ├── .gitignore → Files/folders Git should ignore
                            ├── index.html → Main HTML file, loads React
                            ├── package.json → Project config + dependencies
                            ├── vite.config.js → Vite configuration
                        </code>
                    </div>
                    <p>
                        <ul>
                            <li><span class="bolder">node_modules/:</span> Contains all libraries and dependencies installed via npm (e.g.,
                                React, Vite). It's auto-generated when you run <code>npm install</code> and should not be edited or committed to
                                Git due to its size.</li>
                        
                            <li><span class="bolder">public/:</span> Stores static files like images or icons (e.g., vite.svg) that are served
                                directly at the app's root URL (e.g., <code>/vite.svg</code>). These files aren’t processed or bundled by Vite.
                            </li>
                        
                            <li><span class="bolder">public/vite.svg:</span> A sample static file (the Vite logo) included by default. You can
                                add other static assets like <code>favicon.ico</code> here for direct access.</li>
                        
                            <li><span class="bolder">src/:</span> The main folder for your React app's source code, including components,
                                styles, and assets that Vite processes during development and build.</li>
                        
                            <li><span class="bolder">src/assets/:</span> Holds assets like images or fonts that are imported into your code
                                (e.g., <code>import logo from './assets/logo.png'</code>). Vite optimizes these for production, unlike public/
                                files.</li>
                        
                            <li><span class="bolder">src/App.jsx:</span> The primary React component defining your app’s UI. It’s a functional
                                component using JSX, where you can start building your interface (e.g., edit to add HTML-like content).</li>
                        
                            <li><span class="bolder">src/main.jsx:</span> The entry point where the React app is rendered into the DOM. It
                                imports App.jsx and uses <code>ReactDOM.createRoot</code> to attach it to the <code>index.html</code>’s
                                <code>&lt;div id="root"&gt;</code>.</li>
                        
                            <li><span class="bolder">src/index.css:</span> A global CSS file for app-wide styles, imported in
                                <code>main.jsx</code>. Use it for base styles (e.g., <code>body { margin: 0; }</code>) or add component-specific
                                styles elsewhere.</li>
                        
                            <li><span class="bolder">.gitignore:</span> A Git configuration file listing files/folders to ignore (e.g.,
                                <code>node_modules/</code>, <code>dist/</code>). Prevents unnecessary or sensitive files from being tracked.
                            </li>
                        
                            <li><span class="bolder">index.html:</span> The main HTML template served by Vite. It includes a
                                <code>&lt;div id="root"&gt;&lt;/div&gt;</code> where the React app is injected and links to scripts/styles.</li>
                        
                            <li><span class="bolder">package.json:</span> Defines project details (name, version) and lists dependencies (e.g.,
                                React) and scripts (e.g., <code>npm run dev</code>, <code>npm run build</code>) for running and building the
                                app.</li>
                        
                            <li><span class="bolder">vite.config.js:</span> Configures Vite's behavior, like plugins, server settings, or build
                                options. You can customize it to add features like TypeScript or CSS preprocessors.</li>
                        </ul>
                    </p>
                </div>
            </div>
        </section>


        <!-- React Components -->
        <section id="section3" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>React Components</h2>
                <p>
                    Components are independent, reusable pieces of UI (e.g., buttons, headers, forms) written as JavaScript functions or classes. They accept inputs (props) and return JSX to describe what should be rendered.
                </p>
                <p>
                    Purpose: Break down the UI into manageable, reusable parts, making code modular and easier to maintain.
                </p>
                <p>
                    Types:
                    <ul>
                        <li>Functional Components: Modern, preferred way using functions (e.g., function Button() { return &lt;button&gt; Click me &lt;'/button&gt;; }).</li>
                        <li>Class Components: Older approach using ES6 classes, less common since Hooks were introduced.</li>
                    </ul>
                </p>
                <div class="note-l2">
                    <h3>Creating and Organizing Components</h3>
                    <p>
                        Components are primarily located in the src/ directory or its sub folders.
                    </p>
                    <div class="note-l3">
                        <h4>src/App.jsx:</h4>
                        <p>
                            Role: This is the main React component, acting as the root of your application's UI.
                        </p>
                        <p>
                            Details: It's a functional component that returns JSX, defining the initial UI. The default Vite template includes a sample App.jsx with a simple layout (e.g., a heading and counter).
                        </p>
                        <p>
                            Usage: You can modify App.jsx to include other components or add your UI logic.
                        </p>
                        <div class="code-container">
                            <code>
                                //Example:
                                import './index.css';

                                function App() {
                                    &nbsp;&nbsp;return (
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt; Welcome to My React App &lt;/h1&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt; Built with Vite! &lt;/p&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                    &nbsp;&nbsp;);
                                }

                                export default App;  //export
                            </code>
                        </div>
                    </div>
                    <div class="note-l3">
                        <h4>src/:</h4>
                        <p>
                            Role: The primary folder where you create and organize additional components.
                        </p>
                        <p>
                            Details: While the default Vite setup only includes App.jsx, you can add more components as .jsx files in src/ or subfolders (e.g., src/components/Button.jsx).
                        </p>
                        <div class="code-container">
                            <code>
                                //Example: Create a new component src/components/Button.jsx:
                                function Button({ label }) {
                                    &nbsp;&nbsp;return &lt;button&gt; {label} &lt;/button&gt;;
                                }
                                export default Button;

                                //Then import and use it in App.jsx:
                                import Button from './components/Button.jsx'; //import button to use
                                function App() {
                                    &nbsp;&nbsp;return (
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt; My App &lt;/h1&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Button label="Click Me" /&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                    &nbsp;&nbsp;);
                                }
                            </code>
                        </div>
                    </div>
                    <div class="note-l3">
                        <h4>src/main.jsx:</h4>
                        <p>
                            Role: Not a component itself but the entry point that renders the App component into the DOM.
                        </p>
                        <p>
                            Details: It uses ReactDOM.createRoot to mount App into the &lt;div id="root"&gt; in index.html. You can wrap App with other components or providers (e.g., Redux) here.
                        </p>
                    </div>
                    <div class="note-l3">
                        <h4>src/index.css:</h4>
                        <p>
                            Role: Provides global styles that can be applied to components.
                        </p>
                        <p>
                            Details: Styles defined here (e.g., body { font-family: Arial; }) affect all components unless overridden by component-specific styles (e.g., CSS modules).
                        </p>
                    </div>
                    <div class="note-l3">
                        <h4>src/assets/:</h4>
                        <p>
                            Role: Stores assets (e.g., images) that components can import.
                        </p>
                        <p>
                            Details: For example, a component might use an image: import logo from './assets/logo.png'; &lt;img src={logo} alt="Logo" /&gt;.
                        </p>
                    </div>
                </div>
                <div class="note-l3">
                    <h4>&lt;ComponentName /&gt; or &lt;ComponentName&gt;&lt;/ComponentName&gt;</h4>
                    <p>
                        These are JSX tags used to render a React component inside another component.
                    </p>
                    <p>
                        <span class="bolder">&lt;ComponentName /&gt;: </span>Purpose: Self-closing tag used to render a component without children (no content between opening and closing tags). 
                        <br> When to Use: When the component doesn't need to wrap other elements or components.
                    </p>
                    <p>
                        <span class="bolder">&lt;ComponentName&gt;&lt;/ComponentName&gt;: </span>Purpose: Opening and closing tags used to render a component with children (content, elements, or other components between the tags). 
                        <br>When to Use: When you want to pass JSX, text, or other components as children to ComponentName. 
                        <br>Example: &lt;ComponentName&gt; &lt;p&gt;Child content&lt;/p&gt; &lt;/ComponentName&gt; renders the component with a paragraph as its child.
                    </p>
                    <div class="code-container">
                        <code>
                            function Welcome() {
                                &nbsp;&nbsp;return &lt;h2&gt;Welcome to the site!&lt;/h2&gt;;
                            }
                            
                            function App() {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Welcome /&gt; //This line renders the Welcome component
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }
                        </code>
                    </div>
                </div>
                <div class="note-l3">
                    <h4>component return only one element?</h4>
                    <p>
                        A component must return only one single parent element. BUT that one element can contain many nested elements inside.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example 1: Incorrect - Multiple siblings without wrapper
                            function MyComponent() {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Title&lt;/h1&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Description&lt;/p&gt; //incorrect - will throw arror
                                &nbsp;&nbsp;);
                            }


                            //Example 2: Correct - With a parent <div>
                            function MyComponent() {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Title&lt;/h1&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Description&lt;/p&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }

                            //This works because you're returning one element (div), which contains other elements inside.
                        </code>
                    </div>
                </div>
            </div>
        </section>


        <!-- Import, Export -->
        <section id="section4" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Import, Export</h2>
                <p>
                    React apps are made of many components stored in different files. You can export components, functions, or variables.
                </p>
                <p>
                    To use code from one file in another, you must: export it from the source file AND import it into the destination file 
                </p>
                <p>
                    Types:
                    <ul>
                        <li>1. Default Export - Use this when you're exporting only one thing from a file.</li>
                        <li>2. Named Export - Use this when you're exporting multiple things from the same file.</li>
                    </ul>
                </p>
                <div class="code-container">
                    <code>
                        //1.Example - Default Export:
                        //Header.jsx
                        function Header() {
                            &nbsp;&nbsp;return &lt;h1&gt;My App&lt;/h1&gt;;
                        }
                        export default Header; // default export


                        //App.jsx
                        import Header from './Header'; // import, no curly braces
                        //You can name it anything when importing.

                        <hr>
                        //2.Example - Named Export:
                        //utils.js
                        export function add(a, b) {
                            &nbsp;&nbsp;return a + b;
                        }
                        
                        export function subtract(a, b) {
                            &nbsp;&nbsp;return a - b;
                        }

                        
                        //In another file
                        import { add, subtract } from './utils'; // use curly braces

                        to rename use like - import { add as addition } from './utils';
                    </code>
                </div>
            </div>
        </section>


        <!-- Writing Markup with JSX -->
        <section id="section5" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Writing Markup with JSX</h2>
                <p>
                    JSX is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it.
                </p>
                <div class="note-l2">
                    <h3>The Rules of JSX</h3>
                    <p>
                        <span class="bolder">1. Return a single root element - </span> To return multiple elements from a component, wrap them with a single parent tag.
                    </p>
                    <p>
                        <span class="bolder">2. Close all the tags - </span> JSX requires tags to be explicitly closed: self-closing tags like &lt;img&gt; must become &lt;img /&gt;, and wrapping tags like &lt;li&gt; oranges must be written as &lt;li&gt;oranges&lt;/li&gt;.
                    </p>
                    <p>
                        <span class="bolder">3. Use CamelCase for Attributes - </span> JSX attributes use camelCase (e.g., className, onClick) instead of HTML's lowercase (e.g., class, onclick).
                    </p>
                    <p>
                        <span class="bolder">4. Capitalize Component Names - </span> Custom components (e.g., &lt;ComponentName /&gt;) must start with a capital letter to distinguish them from HTML elements (e.g., &lt;div&gt;). e.t.c.
                    </p>
                </div>
            </div>
        </section>


        <!-- JavaScript in JSX with Curly Braces -->
        <section id="section6" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>JavaScript in JSX with Curly Braces</h2>
                <p>
                    In JSX, you can write JavaScript expressions directly inside the HTML-like syntax using curly braces {}.
                </p>
                <p>
                    You can embed any JavaScript expression inside JSX - e.g. &lt;h1&gt;{expression}&lt;/h1&gt;. An expression is something that returns a value, like: Variable, Math, Function call, Array e.t.c.
                </p>
                <div class="code-container">
                    <code>
                        //Example:
                        function Title() {
                            &nbsp;&nbsp;let name = "John";
                            &nbsp;&nbsp;return (
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;2 * 2 = {2 * 2}&lt;/p&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Hi, {name}&lt;/p&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                            &nbsp;&nbsp;);
                        }
                        
                        export default Title;

                        //Output:
                        2 * 2 = 4
                        Hi, John
                    </code>
                </div>
            </div>
        </section>


        <!-- React Fragments -->
        <section id="section7" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>React Fragments</h2>
                <p>
                    In React, every component must return a single parent element. But sometimes, you don't want to wrap your elements in an extra &lt;div&gt; just for that. That's where React Fragments come in.
                </p>
                <p>
                    That's where React Fragments come in. Using:
                    <ul>
                        <li>Short Form - &lt;&gt; &lt;/&gt;</li>
                        <li>Full Form - &lt;React.Fragment&gt; &lt;/React.Fragment&gt;</li>
                    </ul>
                    Both do the same thing, but &lt;&gt; &lt;/&gt; is shorter and cleaner.
                </p>
                <div class="code-container">
                    <code>
                        //Example:
                        return (
                            &nbsp;&nbsp;&lt;&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello&lt;/h1&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;World&lt;/p&gt;
                            &nbsp;&nbsp;&lt;/&gt;
                        );
                        //This won't add any extra tags to the DOM.
                    </code>
                </div>
            </div>
        </section>


        <!-- React Props -->
        <section id="section8" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>React Props</h2>
                <p>
                    React components use props(short for properties) to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.
                </p>
                <div class="note-l2">
                    <h3>Usage</h3>
                    <p>
                        Props are passed to a component as attributes in JSX, similar to HTML attributes.
                    </p>
                    <p>
                        The child component accesses props via the props object (or through destructuring).
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            // Parent Component
                            function Parent() {
                                &nbsp;&nbsp;const name = "Alice";
                                &nbsp;&nbsp;return &lt;Child greeting="Hello" name={name} /&gt;; // pass like this
                            }
                            
                            // Child Component
                            function Child(props) {
                                &nbsp;&nbsp;return &lt;h1&gt; {props.greeting}, {props.name}! &lt;/h1&gt;;
                            }
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Destructuring Props</h3>
                    <p>
                        You can destructure props in the function parameter for cleaner code.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            function Child({ greeting, name }) { //use {arg1, arg2...}
                                &nbsp;&nbsp;return &lt;h1&gt;{greeting}, {name}!&lt;/h1&gt;;
                            }
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Default Props</h3>
                    <p>
                        We can set Default values for props.
                    </p>
                    <p>
                        We can assign default values to props directly in the function parameter list using destructuring syntax, like ({ value = "abc" }).
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            function MyComponent({ value = "abc" }) {
                                &nbsp;&nbsp;return &lt;h1&gt;Value: {value}&lt;/h1&gt;;
                            }

                            <hr>
                            //usign defaultProps:
                            function MyComponent(props) {
                                &nbsp;&nbsp;return &lt;h1&gt;Value: {props.value}&lt;/h1&gt;;
                            }
                            
                            MyComponent.defaultProps = { //like this. but above method is preffered
                                &nbsp;&nbsp;value: "abc",
                            };
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Passing Arrays, Objects as Props</h3>
                    <p>
                        Arrays can be passed to a child component to render lists, collections, or other iterable data.
                    </p>
                    <p>
                        Objects are useful for passing structured or complex data, such as configuration settings, user details, or nested data.
                    </p>
                    <div class="code-container">
                        <code>
                            // Parent Component
                            function Parent() {
                                &nbsp;&nbsp;const fruits = ["Apple", "Banana", "Orange"];
                                &nbsp;&nbsp;const user = { name: "Alice", age: 25, city: "New York" };
                                &nbsp;&nbsp;return &lt;Child items={fruits} user={user} /&gt;; // pass like this
                            }
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Rendering Arrays</h3>
                    <p>
                        You will often want to display multiple similar components from a collection of data. You can use the JavaScript array methods to manipulate an array of data. On this page, you'll use filter() and map() with React to filter and transform your array of data into an array of components.
                    </p>
                    <div class="code-container">
                        <code>
                            // Parent Component
                            function Parent() {
                                &nbsp;&nbsp;const fruits = ["Apple", "Banana", "Orange"];
                                &nbsp;&nbsp;return &lt;Child items={fruits} /&gt;;
                            }
                            
                            // Child Component
                            function Child({ items = [] }) {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{items.map((item, index) => (
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li key={index}&gt; {item} &lt;/li&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))}
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;
                                &nbsp;&nbsp;);
                            }

                            //output:
                            - Apple
                            - Banana
                            - Orange

                            //Default Value: { items = [] } ensures that if no items prop is passed, an empty array prevents errors when calling .map().

                            //Key Prop: Use a unique key for each element. If the array items have unique IDs, use those instead of index.
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Accessing Object Props</h3>
                    <p>
                        Accessing object props in a child component is straightforward using dot notation, destructuring, or nested destructuring, with defaults to handle missing data.
                    </p>
                    <div class="code-container">
                        <code>
                            // Parent Component
                            function Parent() {
                                &nbsp;&nbsp;const user = { name: "Alice", age: 25};
                                &nbsp;&nbsp;return &lt;Child user={user} /&gt;;
                            }
                            
                            // Child Component:
                            //Method 1: Destructuring Props in the Parameter:
                            function Child({ user }) { //like this
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Name: {user.name}&lt;/p&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Age: {user.age}&lt;/p&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }

                            <hr>
                            //Method 2: Using the props Object Directly:
                            function Child(props) {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Name: {props.user.name}&lt;/p&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Age: {props.user.age}&lt;/p&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }

                            <hr>
                            //Method 3: Destructuring Inside the Component:
                            function Child({ user = { name: "Guest", age: 18, city: "Unknown" } }) { //passing default values to objects
                                &nbsp;&nbsp;const { name, age, city } = user; //like this
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Name: {props.user.name}&lt;/p&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Age: {props.user.age}&lt;/p&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }

                            //there mey other methods also...
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Function as Props</h3>
                    <p>
                        Functions as props means you can pass a function from a parent component to a child component as a property (prop). The child can then call that function to send data or trigger actions in the parent.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            function Child({ onGreet }) {
                                &nbsp;&nbsp;return &lt;button onClick={onGreet}&gt; Say Hello &lt;/button&gt;;
                            }
                            
                            function Parent() {
                                &nbsp;&nbsp;function greet() {
                                    &nbsp;&nbsp;&nbsp;&nbsp;alert("Hello from Parent!");
                                &nbsp;&nbsp;}
                                &nbsp;&nbsp;return &lt;Child onGreet={greet} /&gt;;
                            }
                        </code>
                    </div>
                </div>
            </div>
        </section>


        <!-- Conditional Rendering -->
        <section id="section9" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Conditional Rendering</h2>
                <p>
                    Conditional rendering in React allows you to display different UI elements or components based on specific conditions, such as user input, application state, or props.
                </p>
                <p>
                    For example, you might show a "Welcome" message for logged-in users or a "Login" button for guests. This is achieved using JavaScript expressions like if statements, ternary operators, or logical operators within JSX.
                </p>
                <div class="note-l2">
                    <h3>Common Techniques for Conditional Rendering</h3>
                    <div class="note-l3">
                        <h4>Using if/else Statements</h4>
                        <p>
                            The simplest approach, often used outside the return statement for complex logic or when rendering entirely different components.
                        </p>
                        <div class="code-container">
                            <code>
                                //Example:
                                function Greeting({ isLoggedIn }) {
                                    &nbsp;&nbsp;if (isLoggedIn) {
                                        &nbsp;&nbsp;&nbsp;&nbsp;return &lt;h1&gt; Welcome back! &lt;/h1&gt;;
                                    &nbsp;&nbsp;}

                                    &nbsp;&nbsp;return &lt;h1&gt; Please sign in. &lt;/h1&gt;;
                                }

                                Use Case: Best for complex conditions or when you need to return different components based on multiple checks.
                            </code>
                        </div>
                    </div>
                    <div class="note-l3">
                        <h4>Using Ternary Operator</h4>
                        <p>
                            The ternary operator (condition ? expr1 : expr2) is concise for simple, inline conditions with two outcomes.
                        </p>
                        <div class="code-container">
                            <code>
                                //Example:
                                function UserStatus({ isLoggedIn }) {
                                    &nbsp;&nbsp;return &lt;h1&gt;{isLoggedIn ? "Welcome, User!" : "Please Login!"}&lt;/h1&gt;;
                                }

                                Use Case: Ideal for simple binary conditions within JSX.
                            </code>
                        </div>
                    </div>
                    <div class="note-l3">
                        <h4>Using Logical AND (&&) Operator</h4>
                        <p>
                            The && operator renders an element only if the condition is true, leveraging JavaScript's short-circuit evaluation.
                        </p>
                        <div class="code-container">
                            <code>
                                //Example:
                                function Notification({ hasMessages }) {
                                    &nbsp;&nbsp;return (
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;Welcome!&lt;/h2&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{hasMessages && &lt;p&gt;You have new messages.&lt;p&gt;}
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                    &nbsp;&nbsp;);
                                }

                                Use Case: Perfect when you want to render something only if a condition is true, with no alternative output.
                            </code>
                        </div>
                    </div>
                    <p>
                        There are other ways also...
                    </p>
                </div>
                <p>
                    We can also style components dynamically using conditionals or other methods...
                </p>
            </div>
        </section>


        <!-- Events -->
        <section id="section10" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Events</h2>
                <p>
                    React events work similar to DOM events but with some differences.
                </p>
                <div class="note-l2">
                    <h3>Event Handling in React</h3>
                    <p>
                        Events in React are handled by passing functions (event handlers) as props to components. These functions are triggered when the event occurs.
                    </p>
                    <p>
                        Events are written in camelCase (onClick, not onclick).
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            function handleClick() {
                                &nbsp;&nbsp;alert("Button clicked!");
                            }

                            function App() {
                                &nbsp;&nbsp;return &lt;button onClick={handleClick}&gt; Click Me &lt;/button&gt;;
                            }
                            //pass function as props to event, but not write () with it(because it calls immediately).

                            <hr>
                            //Passing Inline Functions:
                            &lt;button onClick={()=> alert("Hello React!")} &gt; Say Hello &lt;/button&gt;
                        </code>
                    </div>
                    <p>
                        Prevent Default Behavior: Use event.preventDefault() to stop default browser behavior (e.g., form submission or page refresh).
                    </p>
                </div>
                <div class="note-l2">
                    <h3>Event Object</h3>
                    <p>
                        The event object (SyntheticEvent) is passed to event handlers when an event is triggered (e.g., onClick, onChange).
                    </p>
                    <p>
                        It mirrors the native browser event but is normalized to ensure consistent behavior across browsers. It contains properties and methods to access details about the event, such as the target element, event type, or user input.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            const handleClick = (event) => { //write event or any other name
                                &nbsp;&nbsp;event.preventDefault(); //Method: Prevents browser's default action
                                &nbsp;&nbsp;event.stopPropagation(); //Method: Stops event from bubbling up

                                &nbsp;&nbsp;console.log(event); // SyntheticEvent object
                                &nbsp;&nbsp;console.log(event.type); // "click"
                                &nbsp;&nbsp;console.log(event.target); // Element that triggered the event
                            };

                            function MyComponent() {
                                &nbsp;&nbsp;return &lt;button onClick={handleClick} &gt; Click Me &lt;/button&gt;;
                            }
                        </code>
                    </div>
                </div>
            </div>
        </section>


        <!-- State -->
        <section id="section11" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>State</h2>
                <p>
                    In React, state refers to a built-in object that stores data or information about a component that can change over time, triggering a re-render when updated. State is commonly managed using the useState hook in functional components (introduced in React 16.8) or this.state in class components (less common in modern React).
                </p>
                <div class="note-l3">
                    <h4>Hooks</h4>
                    <p>
                        Hooks, introduced in React 16.8, allow functional components to manage state, side effects, and other React features without class components. They're functions with names starting with use (e.g., useState, useEffect) and can only be called at the top level of functional components or custom hooks(not inside loops, conditions, or nested functions).
                    </p>
                </div>
                <div class="note-l3">
                    <h4>useState</h4>
                    <p>
                        Manages local component state.
                    </p>
                    <p>
                        Syntax: const [state, setState] = useState(initialState);
                    </p>
                </div>
                <div class="code-container">
                    <code>
                        //Example:
                        import React, { useState } from 'react'; //import
                        
                        function Counter() {
                            &nbsp;&nbsp;// Declare a state variable 'count' with initial value 0
                            &nbsp;&nbsp;const [count, setCount] = useState(0);
                            
                            &nbsp;&nbsp;// Event handler to update state
                            &nbsp;&nbsp;const increment = () => {
                                &nbsp;&nbsp;&nbsp;&nbsp;setCount(count + 1); // Updates state and triggers re-render
                            &nbsp;&nbsp;};
                        
                            &nbsp;&nbsp;return (
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Count: {count}&lt;/p&gt; //it will update when button clicked
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={increment}&gt; Increment &lt;/button&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                            &nbsp;&nbsp;);
                        }

                        //How It Works:
                        //useState(0): Initializes the state variable count with a value of 0. Returns an array with the current state value (count) and a setter function (setCount).
                        //Updating state: Call setCount to update count. React schedules a re-render with the new state value.
                        //Re-rendering: The component re-renders, displaying the updated count.
                    </code>
                </div>
                <div class="note-l2">
                    <h3>Callback in State Updater</h3>
                    <p>
                        When you call setState (or setCount, setUser, etc.), React doesn't update the state immediately — it schedules the update. If you update state multiple times in a single render, React may use the same stale (old) value unless you use the callback form.
                    </p>
                    <p>
                        Use to change state when it depends on the current value
                    </p>
                    <div class="code-container">
                        <code>
                            //Wrong Way:
                            const [count, setCount] = useState(0);
                            
                            function increase() {
                                &nbsp;&nbsp;setCount(count + 1);
                                &nbsp;&nbsp;setCount(count + 1);
                            }

                            //Both updates read the old value (0), so both set it to 1.
                            //Final result: count = 1 (not 2 as expected)

                            <hr>
                            //Correct Way:
                            const [count, setCount] = useState(0);
                            
                            function increase() { //use callback
                                &nbsp;&nbsp;setCount((prev) => prev + 1);
                                &nbsp;&nbsp;setCount((prev) => prev + 1);
                            }

                            //First update → prev = 0 → sets to 1. Second update → prev = 1 → sets to 2. Final result: count = 2 (as expected)
                        </code>
                    </div>
                </div>
                <div class="note-l3">
                    <h4>Passing a Function as Initial State</h4>
                    <div class="code-container">
                        <code>
                            const [count, setCount] = useState(() => { 
                                return Math.random();
                            });

                            //Or pass function name but without () - useState(functionName)


                            //Here the function is run only once (when the component mounts).
                            //Useful for expensive calculations (e.g., reading from localStorage, computing something heavy).
                            //React stores the result of Math.random() as the initial state.
                        </code>
                    </div>
                </div>
                <div class="note-l3">
                    <p>
                        React will only trigger a re-render if the new state/props value is actually different from the previous one.
                    </p>
                    <p>
                        e.g - setCount(0); // same value → React skips re-render
                    </p>
                </div>
                <div class="note-l2">
                    <h3>Object State</h3>
                    <p>
                        In React, state can hold objects, and you typically use the useState hook to manage them in functional components. Since objects are reference types, updating them requires special care to ensure immutability and proper re-rendering.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example:
                            function UserProfile() {
                                &nbsp;&nbsp;const [user, setUser] = useState({
                                    &nbsp;&nbsp;&nbsp;&nbsp;name: "Inderjit",
                                    &nbsp;&nbsp;&nbsp;&nbsp;age: 20,
                                    &nbsp;&nbsp;&nbsp;&nbsp;city: "Jalandhar",
                                &nbsp;&nbsp;});
                            
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt; {user.name} ({user.age}) - {user.city} &lt;/h3&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                                &nbsp;&nbsp;);
                            }

                            //user is an object stored in state.
                        </code>
                    </div>
                    <div class="code-container">
                        <code>
                            //Updating Object state:
                            //Wrong Way:
                            setUser({ name: "Singh" });

                            //This replaces the whole object. After this, user becomes { name: "Singh" } and age, city are lost.

                            <hr>
                            //Right Way:
                            setUser({ ...user, name: "Singh" }); //We must copy old state first and then override the field

                            //Now user becomes: { name: "Singh", age: 20, city: "Jalandhar" }

                            <hr>
                            //Using Functional Updater with Objects - If new value depends on old value, use callback:
                            setUser(prev => ({ ...prev, age: prev.age + 1 }));
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Array State</h3>
                    <p>
                        Just like objects, you can store and manage arrays inside useState. Like objects, arrays are reference types, so updates must be immutable to ensure React detects changes and re-renders the component.
                    </p>
                    <p>
                        Immutability: Always create a new array when updating state to avoid mutating the original array directly.
                    </p>
                    <div class="code-container">
                        <code>
                            //Example - Creating Array State:
                            import { useState } from "react";
                            
                            function Fruits() {
                                const [fruits, setFruits] = useState(["Apple", "Banana"]);
                                return &lt;p&gt; {fruits.join(", ")} &lt;/p&gt;;
                            }
                            //fruits is an array in state.
                        </code>
                    </div>
                    <div class="code-container">
                        <code>
                            //Don't Mutate Arrays:
                            fruits.push("Mango");
                            setFruits(fruits); //WRONG

                            //Directly modifying (push, splice, etc.) mutates the old array.
                            //React won't detect changes → no re-render.

                            <hr>
                            //Correct Way - Create New Array (Use spread operator [...oldArray]).
                            // Add new element
                            setFruits([...fruits, "Mango"]);
                            
                            // Remove element - use filter
                            setFruits(fruits.filter(fruit => fruit !== "Banana")); 
                            
                            // Update element - user map
                            setFruits(fruits.map(fruit => fruit === "Apple" ? "Green Apple" : fruit));

                            <hr>
                            //Using Functional Updater with Arrays - When new state depends on old state:
                            setFruits(prev => [...prev, "Orange"]);
                        </code>
                    </div>
                    <div class="code-container">
                        <code>
                            //Rendering Arrays:
                            //React uses .map() to render lists:
                            function Fruits() {
                                &nbsp;&nbsp;const [fruits, setFruits] = useState(["Apple", "Banana", "Mango"]);
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{fruits.map((fruit, index) => (
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li key={index}&gt; {fruit} &lt;/li&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))}
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;
                                &nbsp;&nbsp;);
                            }
                            //Always use key when rendering lists (unique id if possible, not index).
                        </code>
                    </div>
                    <div class="note-l3">
                        <h4>Array of Objects in State</h4>
                        <div class="code-container">
                            <code>
                                function TodoApp() {
                                    &nbsp;&nbsp;const [todos, setTodos] = useState([
                                        &nbsp;&nbsp;&nbsp;&nbsp;{ id: 1, text: "Learn React", done: false },
                                        &nbsp;&nbsp;&nbsp;&nbsp;{ id: 2, text: "Practice DSA", done: true }
                                    &nbsp;&nbsp;]);
                                    
                                    &nbsp;&nbsp;function toggleTodo(id) {
                                        &nbsp;&nbsp;&nbsp;&nbsp;setTodos(prev =&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev.map(todo =&gt;
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;todo.id === id ? { ...todo, done: !todo.done } : todo
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
                                        &nbsp;&nbsp;&nbsp;&nbsp;);
                                    &nbsp;&nbsp;}
                                    
                                    &nbsp;&nbsp;return (
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{todos.map(todo => (
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li key={todo.id}&gt;
                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span style={{ textDecoration: todo.done ? "line-through" : "none" }}&gt; {todo.text} &lt;/span&gt;
                                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick = {() => toggleTodo(todo.id)}&gt; Toggle &lt;/button&gt;
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))}
                                        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;
                                    &nbsp;&nbsp;);
                                }
                            </code>
                        </div>
                    </div>
                </div>
                <div class="note-l3">
                    <h4>Unique Key</h4>
                    <p>
                        In React, the key prop is a special attribute you provide when rendering a list of elements (e.g., using map to render an array). Keys help React identify which items in a list have changed, been added, or been removed, optimizing the rendering process.
                    </p>
                    <p>
                        Key Points on Unique Keys:
                        <ul>
                            <li>Purpose: Keys help React track list items for efficient rendering and updates.</li>
                            <li>Requirement: Each list item needs a unique, stable key prop (e.g., an ID).</li>
                            <li>Best Practice: Use a unique ID from your data (not array indices) for dynamic lists.</li>
                            <li>Why Avoid Indices: Indices cause issues in dynamic lists (e.g., reordering, adding/removing items) as they don't uniquely identify items.</li>
                        </ul>
                    </p>
                    <p>
                        Use Unique IDs: Use id or uuid for keys (install uuid with npm install uuid).
                    </p>
                </div>
            </div>
        </section>


        <!-- Forms in React -->
        <section id="section12" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Forms in React</h2>
                <p>
                    React forms are typically controlled components, meaning the form inputs' values are managed by React state, and updates are handled via event handlers. This ensures predictable behavior and easy data management. Forms can handle simple data (e.g., strings), objects, or arrays, and you can use hooks like useState or useReducer to manage form state.
                </p>
                <p>
                    In HTML, form elements like &lt;input&gt;, &lt;textarea&gt;, and &lt;select%gt; manage their own internal state. In React, state is kept in components and updated with setState(). By syncing form values with React state, we make React the single source of truth. Such form elements are called controlled components.
                </p>
                <div class="code-container">
                    <code>
                        import { useState } from "react";
                        
                        export default function Form() {
                            &nbsp;&nbsp;const [fullName, setFullName] = useState("");
                            
                            &nbsp;&nbsp;function handleNameChange(event) {
                                &nbsp;&nbsp;&nbsp;&nbsp;setFullName(event.target.value);
                            &nbsp;&nbsp;}
                            
                            &nbsp;&nbsp;function handleSubmit(e) {
                                &nbsp;&nbsp;&nbsp;&nbsp;e.preventDefault(); // prevent page reload
                                &nbsp;&nbsp;&nbsp;&nbsp;alert("Submitted: " + fullName);
                            &nbsp;&nbsp;}
                            
                            &nbsp;&nbsp;return (
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;form onSubmit={handleSubmit}&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input placeholder="Enter name" type="text" value={fullName} onChange={handleNameChange} /&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button type="submit"&gt; Submit &lt;/button&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                            &nbsp;&nbsp;);
                        }


                        //value={fullName} → input shows whatever is in state.
                        //onChange={handleNameChange} → updates state whenever user types.
                        //onSubmit={handleSubmit} → stops page refresh & shows alert with current state.
                    </code>
                </div>
                <div class="note-l3">
                    <h4>Form Labels in React</h4>
                    <p>
                        In React, we use &lt;label&gt; just like HTML, but: "for" attribute becomes "htmlFor" (because for is a reserved keyword in JS).
                    </p>
                    <div class="code-container">
                        <code>
                            function FormLabelExample() {
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;form&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label htmlFor="username"&gt; Username: &lt;/label&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input id="username" type="text" placeholder="Enter username" /&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                                &nbsp;&nbsp;);
                            }

                            //but in DOM it is "for" only.

                            <hr>
                            //Label Wrapping Input (Alternative Way):
                            //Instead of htmlFor, you can wrap input inside the label:

                            &lt;label&gt;
                                &nbsp;&nbsp;Username:
                                &nbsp;&nbsp;&lt;input type="text" placeholder="Enter username" /&gt;
                            &lt;/label&gt;

                            //This automatically links the label to the input.
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>Multiple Inputs(with One State Object)</h3>
                    <p>
                        If your form has many fields (name, email, password, etc.), you don't want useState for each one. Instead, keep one object in state, where each property corresponds to a field. This makes the code cleaner and scalable.
                    </p>
                    <div class="code-container">
                        <code>
                            import { useState } from "react";
                            
                            export default function Form() {
                                &nbsp;&nbsp;const [formData, setFormData] = useState({
                                    &nbsp;&nbsp;&nbsp;&nbsp;fullName: "",
                                    &nbsp;&nbsp;&nbsp;&nbsp;username: "",
                                &nbsp;&nbsp;});
                                
                                &nbsp;&nbsp;// Handles input changes - using event.target.name and event.target.value
                                &nbsp;&nbsp;const handleInputChange = (event) => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;const { name, value } = event.target;
                                    &nbsp;&nbsp;&nbsp;&nbsp;setFormData((currData) => ({ ...currData, [name]: value,})); 
                                    &nbsp;&nbsp;&nbsp;&nbsp;// dynamically updates the field
                                &nbsp;&nbsp;};
                                
                                &nbsp;&nbsp;// Handles form submit
                                &nbsp;&nbsp;const handleSubmit = (event) => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;event.preventDefault();
                                    &nbsp;&nbsp;&nbsp;&nbsp;alert(`Full Name: ${formData.fullName}, Username: ${formData.username}`);
                                
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Reset form after submit
                                    &nbsp;&nbsp;&nbsp;&nbsp;setFormData({
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fullName: "",
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;username: "",
                                    &nbsp;&nbsp;&nbsp;&nbsp;});
                                &nbsp;&nbsp;};
                                
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;form onSubmit={handleSubmit}&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt; 
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input value={formData.fullName}
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="fullName"
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={handleInputChange}
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
                                    
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label&gt; 
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input 
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value={formData.username}
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="username"
                                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={handleInputChange}
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/label&gt;
                                        
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button type="submit"&gt; Submit &lt;/button&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                                &nbsp;&nbsp;);
                            }

                            //we are using ([name]: value), the name attribute of the input must match the key name in your state object.
                        </code>
                    </div>
                </div>
                <div class="note-l2">
                    <h3>useEffect</h3>
                    <p>
                        useEffect is a React Hook that lets you perform side effects in functional components. Side effects = code that affects something outside the component (not just rendering). It runs after the component renders and can be controlled with a dependency array.
                    </p>
                    <p>
                        Examples of side effects: Fetching data from an API, Subscribing/unsubscribing (like WebSocket, event listeners), Working with setInterval / setTimeout, Updating document.title e.t.c
                    </p>
                    <p>
                        <span class="bolder">Syntax: useEffect(() => { /* effect */ }, [dependencies]);</span>
                    </p>
                    <div class="note-l3">
                        <h4>useEffect Dependency Arrays Scenarios</h4>
                        <p>
                            <ul>
                                <li>[] (Empty Array): The effect runs once when the component mounts and cleans up when it unmounts. Ideal for one-time setup (e.g., fetching initial data).</li>
                                <li>[value] (With Dependencies): The effect runs on mount and whenever the specified dependencies change. Used for effects tied to specific state or props.</li>
                                <li>No Dependency Array: The effect runs after every render, including initial mount and all updates. Use cautiously, as it can lead to performance issues or infinite loops.</li>
                            </ul>
                        </p>
                    </div>
                    <div class="note-l3">
                        <h4>Key Points</h4>
                        <p>
                            <ul>
                                <li>Cleanup: Return a function from useEffect to clean up (e.g., cancel timers or subscriptions).</li>
                                <li>Purpose: Handles tasks that aren't directly tied to rendering (e.g., API calls, timers).</li>
                            </ul>
                        </p>
                    </div>
                    <div class="code-container">
                        <code>
                            //Example:
                            import React, { useState, useEffect } from 'react'; //import
                            
                            function UserForm() {
                                &nbsp;&nbsp;const [formData, setFormData] = useState({ name: '' });
                                
                                &nbsp;&nbsp;// 1. Empty array: Runs once on mount
                                &nbsp;&nbsp;useEffect(() => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;const saved = localStorage.getItem('formData');
                                    &nbsp;&nbsp;&nbsp;&nbsp;if (saved) setFormData(JSON.parse(saved));
                                    &nbsp;&nbsp;&nbsp;&nbsp;return () => console.log('Cleanup on unmount');
                                &nbsp;&nbsp;}, []); // Empty array
                                
                                &nbsp;&nbsp;// 2. With dependency: Runs when formData changes
                                &nbsp;&nbsp;useEffect(() => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem('formData', JSON.stringify(formData));
                                &nbsp;&nbsp;}, [formData]); // Dependency: formData
                                
                                &nbsp;&nbsp;// 3. No dependency: Runs on every render
                                &nbsp;&nbsp;useEffect(() => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;document.title = formData.name || 'User Form';
                                &nbsp;&nbsp;}); // No dependency array
                                
                                &nbsp;&nbsp;const handleChange = (e) => {
                                    &nbsp;&nbsp;&nbsp;&nbsp;setFormData({ name: e.target.value });
                                &nbsp;&nbsp;};
                                
                                &nbsp;&nbsp;return (
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;form&gt;
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="text" name="name" value={formData.name} 
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={handleChange} placeholder="Name" /&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                                &nbsp;&nbsp;);
                            }
                            
                            export default UserForm;
                        </code>
                    </div>
                </div>
            </div>
        </section>


        <!-- useEffect -->
        <section id="section13" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>useEffect</h2>
                <p>
                    useEffect is a React Hook that lets you perform side effects in functional components. Side effects = code that affects something outside the component (not just rendering). It runs after the component renders and can be controlled with a dependency array.
                </p>
                <p>
                    Examples of side effects: Fetching data from an API, Subscribing/unsubscribing (like WebSocket, event listeners), Working with setInterval / setTimeout, Updating document.title e.t.c
                </p>
                <p>
                    <span class="bolder">Syntax: useEffect(() => { /* effect */ }, [dependencies]);</span>
                </p>
                <div class="note-l3">
                    <h4>useEffect Dependency Arrays Scenarios</h4>
                    <p>
                        <ul>
                            <li>[] (Empty Array): The effect runs once when the component mounts and cleans up when it unmounts. Ideal for one-time setup (e.g., fetching initial data).</li>
                            <li>[value(s)] (With Dependencies): The effect runs on mount and whenever the specified dependencies change. Used for effects tied to specific state or props.</li>
                            <li>No Dependency Array: The effect runs after every render, including initial mount and all updates. Use cautiously, as it can lead to performance issues or infinite loops.</li>
                        </ul>
                    </p>
                </div>
                <div class="note-l3">
                    <h4>Key Points</h4>
                    <p>
                        <ul>
                            <li>Cleanup: Return a function from useEffect to clean up (e.g., cancel timers or subscriptions).</li>
                            <li>Purpose: Handles tasks that aren't directly tied to rendering (e.g., API calls, timers).</li>
                        </ul>
                    </p>
                </div>
                <div class="code-container">
                    <code>
                        //Example:
                        import React, { useState, useEffect } from 'react'; //import
                        
                        function UserForm() {
                            &nbsp;&nbsp;const [formData, setFormData] = useState({ name: '' });
                            
                            &nbsp;&nbsp;// 1. Empty array: Runs once on mount
                            &nbsp;&nbsp;useEffect(() => {
                                &nbsp;&nbsp;&nbsp;&nbsp;const saved = localStorage.getItem('formData');
                                &nbsp;&nbsp;&nbsp;&nbsp;if (saved) setFormData(JSON.parse(saved));
                                &nbsp;&nbsp;&nbsp;&nbsp;return () => console.log('Cleanup on unmount');
                            &nbsp;&nbsp;}, []); // Empty array
                            
                            &nbsp;&nbsp;// 2. With dependency: Runs when formData changes
                            &nbsp;&nbsp;useEffect(() => {
                                &nbsp;&nbsp;&nbsp;&nbsp;localStorage.setItem('formData', JSON.stringify(formData));
                            &nbsp;&nbsp;}, [formData]); // Dependency: formData
                            
                            &nbsp;&nbsp;// 3. No dependency: Runs on every render
                            &nbsp;&nbsp;useEffect(() => {
                                &nbsp;&nbsp;&nbsp;&nbsp;document.title = formData.name || 'User Form';
                            &nbsp;&nbsp;}); // No dependency array
                            
                            &nbsp;&nbsp;const handleChange = (e) => {
                                &nbsp;&nbsp;&nbsp;&nbsp;setFormData({ name: e.target.value });
                            &nbsp;&nbsp;};
                            
                            &nbsp;&nbsp;return (
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;form&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input type="text" name="name" value={formData.name} 
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onChange={handleChange} placeholder="Name" /&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;
                            &nbsp;&nbsp;);
                        }
                        
                        export default UserForm;
                    </code>
                </div>
            </div>
        </section>


        <!-- Material UI -->
        <section id="section14" class="note-section" tabindex="0">
            <div class="note-l1">
                <h2>Material UI</h2>
                <p>
                    Material UI (MUI) is a React component library that implements Google's Material Design principles. It gives you ready-made, customizable UI components (buttons, inputs, dialogs, navigation bars, grids, etc.) so you don't have to build everything from scratch.
                </p>
                <p>
                    Helps in building responsive, accessible, and beautiful UIs quickly. Think of it as Bootstrap for React but with modern design and React-first philosophy.
                </p>
                <div class="code-container">
                    <code>
                        //Installation:
                        //Install core MUI:
                        npm install @mui/material @emotion/react @emotion/styled

                        //@mui/material → Core components
                        //@emotion/react & @emotion/styled → CSS-in-JS styling engine


                        //Install MUI Icons (optional but common):
                        npm install @mui/icons-material

                        //there are other things we can install of it
                    </code>
                </div>
                <div class="code-container">
                    <code>
                        //Basic Example:
                        import * as React from "react";
                        import Button from "@mui/material/Button"; //import like this or see document
                        
                        export default function App() {
                            &nbsp;&nbsp;return (
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt; Hello MUI &lt;/h1&gt;
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Button variant="outlined" color="secondary"&gt;Cancel&lt;/Button&gt;
                                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;
                            &nbsp;&nbsp;);
                        }
                    </code>
                </div>
                <p>
                    We can learn about it more on its documentation or other...
                </p>
            </div>
        </section>

    </main>

    <script>
        // Toggle sidebar for mobile
        const menuToggle = document.querySelector('.menu-toggle');
        const sidebar = document.querySelector('.sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('active');
        });
    </script>
</body>

</html>